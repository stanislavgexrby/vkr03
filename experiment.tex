% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Реализация}
\label{sec:implementation}

\subsection{Архитектура портированной системы}

Портированная система SynGT реализована на языке C++17 и представляет собой модульное решение, состоящее из центральной библиотеки и нескольких прикладных компонентов. В отличие от монолитной структуры исходной системы на Pascal, новая архитектура обеспечивает чёткое разделение ответственности между компонентами и возможность их независимого использования.

\begin{table}[h]
\centering
\caption{Технологии портированной системы}
\label{tab:tech_stack}
\begin{tabular}{p{0.25\textwidth}p{0.65\textwidth}}
\hline
\textbf{Компонент} & \textbf{Технология} \\
\hline
Язык программирования & C++17 (ISO/IEC 14882:2017)~\cite{stroustrup2013cpp} \\
\hline
Система сборки & CMake 3.20+~\cite{cmake}, Ninja (опционально) \\
\hline
Компиляторы & GCC 9+, Clang 10+~\cite{clang}, MSVC 2019+ \\
\hline
GUI Framework & Dear ImGui 1.89+ с DirectX 11 backend~\cite{imgui} \\
\hline
Тестирование & Google Test 1.14.0 \\
\hline
Управление памятью & \texttt{std::unique\_ptr}, \texttt{std::shared\_ptr}, RAII~\cite{meyers2014effective} \\
\hline
Контейнеры & \texttt{std::vector}, \texttt{std::map}, \texttt{std::set}, \texttt{std::string} \\
\hline
Система контроля версий & Git, GitHub \\
\hline
Документация & Doxygen (опционально) \\
\hline
\end{tabular}
\end{table}

\subsubsection{Выбор технологий}

\textbf{C++17}~\cite{stroustrup2013cpp,meyers2014effective} выбран как современный стандарт, обеспечивающий баланс между новыми возможностями (структурированные привязки, \texttt{std::optional}, \texttt{if constexpr}) и широкой поддержкой компиляторами.

\textbf{CMake}~\cite{cmake} используется для кросс-платформенной сборки и управления зависимостями. Система сборки автоматически обнаруживает компилятор, настраивает флаги оптимизации и загружает Google Test при необходимости.

\textbf{Dear ImGui}~\cite{imgui} выбран для графического интерфейса благодаря лёгкости интеграции, минимальным зависимостям и возможности создания прототипов без изучения сложных GUI-фреймворков. В отличие от Qt~\cite{qt} или wxWidgets~\cite{wxwidgets}, ImGui не требует MOC-генерации или сложной системы сигналов и слотов.

\textbf{Google Test} обеспечивает современный подход к модульному тестированию с поддержкой параметризованных тестов и подробных отчётов о провалах.

\subsection{Процесс портирования}

Портирование выполнялось итеративно в соответствии с задачами, сформулированными в постановке работы (см. раздел~\ref{sec:task}).

\subsubsection{Этап 1: Анализ исходного кода}

Первым этапом стал детальный анализ исходной системы на Pascal~\cite{fedorchenko1997}. Были изучены все модули (21 единица компиляции: \texttt{Main}, \texttt{Child}, \texttt{Grammar}, \texttt{RegularExpression}, \texttt{DrawObject}, \texttt{Creator}, \texttt{TransGrammar}, \texttt{Minimization}, \texttt{DFA2REGEX}, \texttt{Analyzer} и другие), выявлены ключевые алгоритмы и структуры данных. Особое внимание уделялось алгоритму размещения графических объектов, реализованному в семи взаимосвязанных методах класса \texttt{TRE\_Tree}.

Анализ показал, что исходная система содержит около 12000 строк кода Pascal (без учёта форм VCL). Основные сложности заключались в тесной связанности модулей с VCL-компонентами и отсутствии явного разделения между логикой системы и представлением.

\subsubsection{Этап 2: Проектирование архитектуры}

На основе анализа была разработана модульная архитектура на C++. Ключевыми решениями стали следующие.

\begin{itemize}
    \item \textbf{Выделение библиотеки}: вся логика помещена в отдельную библиотеку \texttt{libsyngt}, независимую от GUI.
    \item \textbf{Иерархия классов}: сохранена объектно-ориентированная структура с виртуальными методами для полиморфного поведения узлов дерева.
    \item \textbf{Неизменяемость where possible}: константные методы и параметры используются везде, где не требуется модификация.
\end{itemize}

\subsubsection{Этап 3: Реализация ядра}

Реализация началась с базовых классов модуля Core. Класс \texttt{Grammar} стал центральной точкой, управляющей всеми списками и обеспечивающей их координацию. Далее были реализованы списки (\texttt{TerminalList}, \texttt{NonTerminalList} и др.) с использованием стандартных контейнеров~\cite{stroustrup2013cpp} вместо специализированных классов Pascal.

Парсер RBNF был портирован с сохранением структуры рекурсивного спуска~\cite{aho2006compilers,grune2012parsing}. Методы \texttt{parseE}, \texttt{parseT}, \texttt{parseF}, \texttt{parseU}, \texttt{parseK} точно соответствуют исходной грамматике, что облегчило верификацию корректности разбора.

Иерархия классов регулярных выражений (\texttt{RETree}) была реализована с использованием полиморфизма~\cite{gamma1994design}. Каждый узел дерева способен создавать свою копию (\texttt{copy()}), сохранять себя (\texttt{save()}), преобразовываться в строку (\texttt{toString()}) и генерировать графические объекты (\texttt{drawObjectsToRight()}).

\subsubsection{Этап 4: Портирование алгоритма визуализации}

Наиболее сложным этапом стало портирование алгоритма размещения графических объектов. Оригинальная реализация использовала семь взаимосвязанных методов (\texttt{DrawObjectsToRight}, \texttt{DrawObjectsToDown}, \texttt{DrawObjectsCanDown}, \texttt{DrawObjectsFromPoint}, \texttt{DrawObjectsToPoint}, \texttt{DrawObjectsToBothLastPoints}, \texttt{DrawObjectsToDownWithBothDownPoints}), каждый из которых рекурсивно вызывал другие методы с передачей контекста через множество параметров.

После анализа оригинальной системы было принято решение о \textbf{упрощении алгоритма визуализации}. Вместо портирования всех семи методов с их сложной взаимосвязанной логикой, реализован единый метод \texttt{drawObjectsToRight} для каждого типа узла дерева (\texttt{REAnd}, \texttt{REOr}, \texttt{REIteration}), который самостоятельно выполняет всю необходимую визуализацию.

\textbf{Причины упрощения} представлены ниже.

\begin{itemize}
    \item Семь методов оригинальной системы тесно связаны с особенностями VCL и содержат множество нюансов взаимодействия, которые трудно воспроизвести без графического контекста.
    \item Многие методы использовались только для специфических случаев (например, \texttt{DrawObjectsToBothLastPoints} для сложных конструкций с макросами).
    \item Упрощенный подход позволяет генерировать корректные диаграммы для всех основных конструкций RBNF без воспроизведения всех деталей оригинального алгоритма.
\end{itemize}

\textbf{Реализованный подход} основан на следующем.

\begin{enumerate}
    \item Каждый тип узла (AND, OR, Iteration, Terminal, NonTerminal) реализует метод \texttt{drawObjectsToRight}, который создаёт графические объекты, соответствующие этому узлу, и рекурсивно вызывает \texttt{drawObjectsToRight} для дочерних узлов.

    \item Для операции AND (последовательность) объекты размещаются горизонтально один за другим.

    \item Для операции OR (альтернатива) используется алгоритм:
        \begin{itemize}
            \item Создается точка разветвления (\texttt{DrawObjectPoint}).
            \item Для каждой альтернативы рекурсивно создаются объекты по вертикали.
            \item Все ветви сходятся в финальной точке схождения.
        \end{itemize}

    \item Для операции Iteration (итерация \texttt{A \# B}) создаётся цикл с обратной стрелкой: первый операнд размещается горизонтально, затем создаётся точка с двумя входящими стрелками, одна из которых идёт от второго операнда (тело цикла).
\end{enumerate}

\textbf{Ключевые технические решения} представлены ниже.

\begin{itemize}
    \item \textbf{Управление владением объектами}: В Pascal объекты создавались и добавлялись в список, который управлял их временем жизни. В C++ это реализовано через передачу \texttt{std::unique\_ptr}~\cite{meyers2014effective} в метод \texttt{add} класса \texttt{DrawObjectList}.

    \item \textbf{Передача результатов между вызовами}: Методы возвращают сырой указатель (non-owning) на последний созданный объект, чтобы следующий метод мог присоединить к нему стрелку.

    \item \textbf{Вычисление координат}: Алгоритм размещения рекурсивно вычисляет координаты каждого объекта, учитывая высоту поддеревьев. Параметр \texttt{height} передаётся по ссылке и модифицируется при рекурсивном возврате.

    \item \textbf{Направление стрелок}: Параметр \texttt{ward} (\texttt{cwFORWARD}, \texttt{cwBACKWARD}, \texttt{cwNONE}) определяет, требуется ли отрисовка направляющих маркеров на стрелках.

    \item \textbf{Ограничения упрощенного подхода}: Упрощенный алгоритм корректно визуализирует все базовые конструкции RBNF, однако может отличаться от оригинала в деталях размещения для особо сложных вложенных конструкций с макросами и множественными уровнями альтернатив. Эти отличия не влияют на читаемость диаграмм и понимание структуры грамматики.
\end{itemize}
\subsubsection{Этап 5: Разработка тестов}

Для верификации корректности портирования был создан набор модульных тестов, организованных по категориям, представленным ниже.

\begin{itemize}
    \item \textbf{core} --- тесты базовых классов (Grammar, списки, NTListItem)
    \item \textbf{parser} --- тесты парсера RBNF на различных грамматиках
    \item \textbf{regex} --- тесты классов регулярных выражений
    \item \textbf{transform} --- тесты алгоритмов преобразования грамматик
    \item \textbf{analysis} --- тесты алгоритмов анализа
\end{itemize}

Система сборки CMake автоматически обнаруживает все файлы \texttt{test\_*.cpp} и создаёт для каждого отдельный исполняемый модуль. Поддерживается параллельное выполнение тестов и фильтрация по категориям (см. раздел~\ref{subsec:testing}).

\subsubsection{Этап 6: Реализация приложений}

\textbf{Консольное приложение} (\texttt{syngt\_cli}) предоставляет интерфейс командной строки для основных операций: разбор грамматик, проверка LL(1), устранение левой рекурсии, факторизация, удаление бесполезных символов, вычисление FIRST/FOLLOW множеств (см. раздел~\ref{subsec:cli_app}).

\textbf{Графическое приложение} (\texttt{syngt\_gui}) реализовано на базе Dear ImGui и обеспечивает интерактивное редактирование грамматик (см. раздел~\ref{subsec:gui_app}).

\subsection{Общая структура проекта}

Проект организован следующим образом.

\begin{itemize}
    \item \textbf{libsyngt} --- основная библиотека, содержащая всю логику системы (см. раздел~\ref{subsec:libsyngt_structure}).
    \item \textbf{syngt\_cli} --- консольное приложение для пакетной обработки грамматик (см. раздел~\ref{subsec:cli_app}).
    \item \textbf{syngt\_gui} --- графическое приложение с интерфейсом на базе ImGui (см. раздел~\ref{subsec:gui_app}).
    \item \textbf{tests} --- набор модульных тестов на базе Google Test (см. раздел~\ref{subsec:testing}).
    \item \textbf{examples} --- примеры использования библиотеки и тестовые грамматики.
\end{itemize}

Такая структура позволяет использовать библиотеку \texttt{libsyngt} как самостоятельный компонент в других проектах, что было невозможно в исходной реализации.

\subsection{Структура библиотеки libsyngt}
\label{subsec:libsyngt_structure}

Библиотека организована по модульному принципу, где каждый модуль отвечает за определённый аспект функциональности. Основные модули представлены ниже.

\textbf{Модуль Core} (6 файлов реализации, 6 заголовочных файлов) содержит базовые классы для работы с грамматиками: \texttt{Grammar}, \texttt{TerminalList}, \texttt{NonTerminalList}, \texttt{SemanticList}, \texttt{MacroList}, \texttt{NTListItem}. Обеспечивает управление словарями терминалов и нетерминалов, загрузку и сохранение грамматик в файлы.

\textbf{Модуль Regex} (6 файлов реализации, 16 заголовочных файлов) реализует иерархию классов для представления синтаксических деревьев: \texttt{RETree} (базовый класс), \texttt{RETerminal}, \texttt{RENonTerminal}, \texttt{RESemantic}, \texttt{REMacro} (листовые узлы), \texttt{REAnd}, \texttt{REOr}, \texttt{REIteration} (бинарные операции), \texttt{REEmpty} (epsilon). Каждый класс реализует методы для копирования, сохранения, преобразования в строку и генерации графических объектов.

\textbf{Модуль Parser} (2 файла реализации, 2 заголовочных файла) реализует рекурсивный спуск для разбора RBNF-грамматик. Парсер построен по грамматике, описанной ниже.
\begin{verbatim}
E = T [';' T]*          (альтернативы)
T = F [',' F]*          (последовательности)
F = U ['#' U]*          (бинарная итерация)
U = K ['*' | '+' ]*     (унарная итерация)
K = Term | NonTerm | Semantic | Macro | '(' E ')' | '[' E ']'
\end{verbatim}

\textbf{Модуль Graphics} (3 файла реализации, 5 заголовочных файлов) содержит классы для представления графических объектов диаграмм: \texttt{DrawObject} (базовый класс), \texttt{DrawObjectTerminal}, \texttt{DrawObjectNonTerminal}, \texttt{DrawObjectMacro}, \texttt{DrawObjectPoint}, \texttt{DrawObjectFirst}, \texttt{DrawObjectLast}. Реализует алгоритм размещения с единым методом \texttt{drawObjectsToRight}. Класс \texttt{DrawObjectList} управляет коллекцией объектов, выделением и координацией размещения.

\textbf{Модуль Transform} (4 файла реализации, 4 заголовочных файла) реализует алгоритмы преобразования грамматик~\cite{aho2006compilers}.

\begin{itemize}
    \item \texttt{LeftElimination} --- устранение левой рекурсии путём замены $A \to A\alpha \mid \beta$ на $A \to \beta A'$, $A' \to \alpha A' \mid \epsilon$.
    \item \texttt{LeftFactorization} --- левая факторизация общих префиксов: $A \to \alpha\beta \mid \alpha\gamma$ преобразуется в $A \to \alpha A'$, $A' \to \beta \mid \gamma$.
    \item \texttt{RemoveUseless} --- удаление недостижимых и непродуктивных символов.
    \item \texttt{FirstFollow} --- вычисление множеств FIRST и FOLLOW для LL(1)-анализа.
\end{itemize}

\textbf{Модуль Analysis} (2 файла реализации, 3 заголовочных файла) содержит алгоритмы анализа грамматик~\cite{hopcroft2006automata}.

\begin{itemize}
    \item \texttt{ParsingTable} --- построение таблицы разбора LL(1) и проверка на конфликты.
    \item \texttt{Minimization} --- построение таблиц минимизации автоматов.
    \item \texttt{DFAToRegex} --- преобразование детерминированного конечного автомата в регулярное выражение по алгоритму Ардена.
\end{itemize}

\textbf{Модуль Utils} (3 файла реализации, 5 заголовочных файлов) содержит вспомогательные классы.

\begin{itemize}
    \item \texttt{Creator} --- утилиты для создания графических объектов из деревьев регулярных выражений.
    \item \texttt{UndoRedo} --- система отмены и повтора действий для графического редактора.
    \item \texttt{SemanticIDList} --- список идентификаторов семантических действий.
    \item \texttt{CharProducer} --- потоковый интерфейс для чтения символов при парсинге.
\end{itemize}

\subsection{Консольное приложение syngt\_cli}
\label{subsec:cli_app}

Консольное приложение предоставляет доступ ко всем функциям библиотеки через интерфейс командной строки, что позволяет автоматизировать обработку грамматик и интегрировать систему в скрипты сборки.

\subsubsection{Основные команды консольного приложения}

Приложение поддерживает следующие команды.

\begin{itemize}
    \item \textbf{parse} --- разбор грамматики и вывод структуры.
\begin{verbatim}
syngt_cli parse input.grm
\end{verbatim}

    \item \textbf{check-ll1} --- проверка грамматики на LL(1)-свойство.
\begin{verbatim}
syngt_cli check-ll1 grammar.grm
\end{verbatim}

    \item \textbf{eliminate} --- устранение левой рекурсии.
\begin{verbatim}
syngt_cli eliminate input.grm output.grm
\end{verbatim}

    \item \textbf{factorize} --- левая факторизация.
\begin{verbatim}
syngt_cli factorize input.grm output.grm
\end{verbatim}

    \item \textbf{remove-useless} --- удаление бесполезных символов.
\begin{verbatim}
syngt_cli remove-useless input.grm output.grm
\end{verbatim}

    \item \textbf{regularize} --- полная регуляризация (все преобразования).
\begin{verbatim}
syngt_cli regularize input.grm output.grm
\end{verbatim}

    \item \textbf{first-follow} --- вычисление FIRST/FOLLOW множеств.
\begin{verbatim}
syngt_cli first-follow grammar.grm
\end{verbatim}

\end{itemize}

\subsection{Графическое приложение syngt\_gui}
\label{subsec:gui_app}

Графическое приложение обеспечивает интерактивную работу с грамматиками через современный пользовательский интерфейс на базе Dear ImGui с DirectX 11 backend для Windows.

\subsubsection{Основные компоненты интерфейса}

Интерфейс приложения состоит из следующих панелей (см. рисунок~\ref{fig:gui_main}). 

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{figures/main.png}
\caption{Главное окно графического приложения syngt\_gui}
\label{fig:gui_main}
\end{figure}



\textbf{Панель редактора грамматики} (слева, вкладка Grammar Editor) --- текстовый редактор синтаксиса RBNF (см. рисунок~\ref{fig:gui_main}). Позволяет редактировать грамматику или после парсинга (кнопка Parse), или после того, как была загружена через файл .grm. Кнопка Clear отвечает за сброс текущей грамматики. Ниже описаны меню в верхней части программы.

\begin{enumerate}

    \item \textbf{Система сохранения и загрузки файла} (меню File в левом верхнем углу) (см. рисунок~\ref{fig:gui_file}) предоставляет возможности для загрузки (Open...), сохранения текущего файла (Save), сохранения с другим именем (Save As...) и выхода из программы (Exit).

\begin{figure}[H]
\centering
\includegraphics[width=0.2\textwidth]{figures/file.png}
\caption{Меню с действиями по загрузке и сохранению грамматик}
\label{fig:gui_file}
\end{figure}

    \item \textbf{Система Undo/Redo} позволяет восстанавливать изменения в грамматике (см. рисунок~\ref{fig:gui_edit}).

\begin{figure}[H]
\centering
\includegraphics[width=0.2\textwidth]{figures/edit.png}
\caption{Меню с действиями по восстановлению изменений}
\label{fig:gui_edit}
\end{figure}

    \item \textbf{Меню действий с грамматикой} позволяет производить различные действия с грамматикой (см. рисунок~\ref{fig:gui_grammar}). Подробнее про них написано ниже.

\begin{figure}[H]
\centering
\includegraphics[width=0.2\textwidth]{figures/grammar.png}
\caption{Меню с действиями с грамматикой}
\label{fig:gui_grammar}
\end{figure}

    \item \textbf{Справочная система} (меню Help -> Show Help) предоставляет краткое руководство по синтаксису RBNF и горячим клавишам (см. рисунок~\ref{fig:gui_help}).

\begin{figure}[H]
\centering
\includegraphics[width=0.2\textwidth]{figures/help.png}
\caption{Встроенная справочная система}
\label{fig:gui_help}
\end{figure}

\end{enumerate}

\textbf{Область визуализации} (вкладка Syntax Diagram) --- отображение синтаксической диаграммы (см. рисунок~\ref{fig:diagram}) для выбранного нетерминала с поддержкой:
\begin{itemize}
    \item Перемещения (левая кнопка мыши на объекте + перетаскивание)
    \item Выделения объектов (левая кнопка мыши все объекта + перетаскивание)
    \item Контекстное меню (правая кнопка мыши), содержащее следующее.
    \begin{itemize}
        \item Edit Symbol
        \item Remove Symbol
        \item Add Terminal (Or)
        \item Add Terminal (And)
        \item Add Non-Terminal (Create new)
        \item Add Non-Terminal Reference(Or)
        \item Add Non-Terminal Reference(And)
    \end{itemize}
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{figures/diagram.png}
\caption{Окно диаграммы графического приложения syngt\_gui}
\label{fig:diagram}
\end{figure}

\textbf{Список нетерминалов} (центральная верхняя панель во вкладке Syntax Diagram) --- выбор активного нетерминала для визуализации и редактирования (см. рисунок~\ref{fig:gui_select}).

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{figures/selection.png}
\caption{Список нетерминалов с выбором активного правила}
\label{fig:gui_select}
\end{figure}


\textbf{Редактор правил} (центральная нижняя панель во вкладке Syntax Diagram) --- текстовое поле для редактирования правила выбранного нетерминала (см. рисунок~\ref{fig:gui_rule}). Кнопка «Build Rule» применяет изменения и перестраивает диаграмму.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{figures/rule.png}
\caption{Поле для ручного редактирования выбранного правила}
\label{fig:gui_rule}
\end{figure}

\textbf{Консоль вывода} (правая нижняя панель) --- отображение сообщений о разборе, ошибках и результатах операций (см. рисунок~\ref{fig:gui_output}).

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{figures/output.png}
\caption{Поле для вывода результатов выполнения операций в программе}
\label{fig:gui_output}
\end{figure}

Ниже представлены примеры вывода результатов некоторых действий в программе.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{figures/o1.png}
\caption{Поле вывода после успешного устранения левой рекурсии}
\label{fig:gui_output}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{figures/o2.png}
\caption{Поле вывода после успешной левой факторизации}
\label{fig:gui_output}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{figures/o3.png}
\caption{Поле вывода после успешной проверки грамматики на LL(1)}
\label{fig:gui_output}
\end{figure}

\textbf{Меню преобразований} (правая верхняя панель), которое отображает меню «Operations» для применения различных преобразований к грамматике (см. рисунок~\ref{fig:gui_transform_menu}).

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{figures/operations.png}
\caption{Меню действий для грамматики}
\label{fig:gui_transform_menu}
\end{figure}

Доступные действия:
\begin{itemize}
    \item \textbf{Eliminate Left Recursion} --- устранение левой рекурсии для всех нетерминалов
    \item \textbf{Left Factorization} --- левая факторизация общих префиксов
    \item \textbf{Remove Useless Symbols} --- удаление недостижимых и непродуктивных символов
    \item \textbf{Check LL(1)} --- проверка грамматики на LL(1)-свойство с выводом результатов
\end{itemize}

\subsubsection{Примеры визуализации}

На рисунках~\ref{fig:diagram_simple}--\ref{fig:diagram_iteration} представлены примеры визуализации синтаксических диаграмм для различных конструкций RBNF.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{figures/s1.png}
\caption{Визуализация последовательности терминалов и нетерминалов}
\label{fig:diagram_simple}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{figures/s2.png}
\caption{Визуализация альтернативы (OR)}
\label{fig:diagram_or}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{figures/s3.png}
\caption{Визуализация итерации (повторения)}
\label{fig:diagram_iteration}
\end{figure}

\subsection{Возникшие сложности и их решения}

В процессе портирования возникли следующие технические проблемы.

\subsubsection{Управление памятью и временем жизни объектов}

\textbf{Проблема}: Pascal использует автоматический подсчёт ссылок для объектов (\texttt{TObject}), тогда как C++ требует явного управления. Исходная система создавала объекты оператором \texttt{Create} и полагалась на VCL для их удаления.

\textbf{Решение}: Все владеющие указатели реализованы через \texttt{std::unique\_ptr}~\cite{meyers2014effective}. Метод \texttt{add} класса \texttt{DrawObjectList} принимает \texttt{std::unique\_ptr<DrawObject>}, обеспечивая передачу владения. Для невладеющих ссылок (например, \texttt{fromDO} в методах размещения) используются сырые указатели.

\subsubsection{Рекурсивное построение графических объектов}

\textbf{Проблема}: Методы \texttt{drawObjectsToRight} и связанные рекурсивно вызывают друг друга, создавая цепочки объектов. В Pascal параметры передавались как \texttt{var} (по ссылке), что позволяло модифицировать их в вызываемых методах.

\textbf{Решение}: В C++ используется передача параметров по ссылке (например, \texttt{int\& height}, \texttt{SemanticIDList*\& semantics}). Ссылка на указатель (\texttt{SemanticIDList*\&}) позволяет методу установить его в \texttt{nullptr} после обработки, сигнализируя вызывающему коду о том, что семантики были присоединены к стрелке.

\subsubsection{Преобразование строк и кодировки}

\textbf{Проблема}: Исходная система использовала \texttt{AnsiString} с кодировкой Windows-1251, тогда как современный C++ работает с UTF-8. Это вызвало проблемы при загрузке файлов с русскими идентификаторами.

\textbf{Решение}: Файлы грамматик сохраняются в UTF-8. Класс \texttt{CharProducer} корректно обрабатывает многобайтовые последовательности UTF-8 при разборе идентификаторов.

\subsubsection{Отсутствие графического контекста в библиотеке}

\textbf{Проблема}: Исходная система была тесно связана с VCL, и классы \texttt{DrawObject} непосредственно рисовали себя на \texttt{TCanvas}. При портировании требовалось отделить логику размещения от отрисовки.

\textbf{Решение}: Классы \texttt{DrawObject} теперь хранят только геометрические параметры (координаты, размеры), но не выполняют отрисовку. GUI-приложение извлекает эти параметры и отрисовывает объекты средствами ImGui. Это обеспечивает независимость библиотеки от графического фреймворка.

\subsubsection{Компиляция под различными платформами}

\textbf{Проблема}: Необходимо обеспечить компиляцию под Windows (MSVC, MinGW), Linux (GCC, Clang) и macOS (Clang) с различными наборами предупреждений и флагов.

\textbf{Решение}: CMake-скрипты используют generator expressions для настройки флагов компиляции в зависимости от компилятора. Включены флаги \texttt{-Wall -Wextra -Wpedantic -Werror} (GCC/Clang) и \texttt{/W4 /WX} (MSVC), что обеспечивает высокое качество кода~\cite{martin2008clean} и раннее обнаружение ошибок.

\subsection{Метрики кода}

Итоговые метрики портированной системы представлены в таблице~\ref{tab:code_metrics}.

\begin{table}[H]
\centering
\small
\caption{Метрики кода портированной системы}
\label{tab:code_metrics}
\begin{tabular}{lrr}
\hline
\textbf{Компонент} & \textbf{Файлы} & \textbf{Строк кода} \\
\hline
\multicolumn{3}{l}{\textbf{Библиотека libsyngt}} \\
\ \ \ Заголовочные файлы (.h) & 47 & \textasciitilde 3500 \\
\ \ \ Файлы реализации (.cpp) & 23 & \textasciitilde 4200 \\
\ \ \ Итого libsyngt & 70 & \textasciitilde 7700 \\
\hline
\multicolumn{3}{l}{\textbf{Консольное приложение syngt\_cli}} \\
\ \ \ main.cpp & 1 & \textasciitilde 400 \\
\hline
\multicolumn{3}{l}{\textbf{Графическое приложение syngt\_gui}} \\
\ \ \ main.cpp + ImGui интеграция & 1 & \textasciitilde 600 \\
\hline
\multicolumn{3}{l}{\textbf{Тесты}} \\
\ \ \ Модульные тесты (test\_*.cpp) & 18 & \textasciitilde 1800 \\
\hline
\multicolumn{3}{l}{\textbf{Примеры и документация}} \\
\ \ \ Примеры использования & 2 & \textasciitilde 200 \\
\ \ \ Тестовые грамматики (.grm) & 15 & --- \\
\hline
\textbf{Всего} & \textbf{92} & \textbf{\textasciitilde 10700} \\
\hline
\end{tabular}
\end{table}

Сравнение с исходной системой представлено в таблице~\ref{tab:comparison_metrics}.

\begin{table}[h]
\centering
\small
\caption{Сравнение метрик исходной и портированной систем}
\label{tab:comparison_metrics}
\begin{tabular}{p{0.35\linewidth}cc}
\hline
\textbf{Метрика} & \textbf{Pascal (SynGT)} & \textbf{C++ (Портирование)} \\
\hline
Язык & Object Pascal & C++17 \\
Строк кода (без GUI форм) & \textasciitilde 12000 & \textasciitilde 7700 (библиотека) \\
Единиц компиляции & 21 модуль & 70 файлов (47 .h + 23 .cpp) \\
Модульных тестов & 0 & 18 тестовых модулей \\
Зависимость от GUI & VCL (тесно связано) & Отсутствует в библиотеке \\
Кросс-платформенность & Windows only & Windows, Linux, macOS \\
\hline
\end{tabular}
\end{table}

Уменьшение количества строк кода библиотеки связано с несколькими факторами.

\begin{itemize}
    \item Использование стандартных контейнеров C++ вместо реализации собственных структур данных.
    \item Исключение GUI-специфичного кода из библиотеки (в Pascal графические методы были частью классов \texttt{TRE\_Tree}).
    \item Более компактный синтаксис C++ для итераторов, инициализации объектов и управления памятью.
    \item Удаление избыточных проверок, теперь гарантированных системой типов и умными указателями.
\end{itemize}

\subsection{Тестирование и верификация}
\label{subsec:testing}

\subsubsection{Структура тестов}

Система тестирования построена на базе Google Test и организована по категориям. Каждая категория содержит несколько тестовых модулей, проверяющих определённую часть функциональности.

\textbf{Категория core} --- тесты базовых классов, представленные ниже.

\begin{itemize}
    \item \texttt{test\_grammar.cpp} --- загрузка, сохранение, управление списками
    \item \texttt{test\_terminal\_list.cpp} --- операции со списком терминалов
    \item \texttt{test\_nonterminal\_list.cpp} --- операции со списком нетерминалов
\end{itemize}

\textbf{Категория parser} --- тесты разбора грамматик, представленные ниже.

\begin{itemize}
    \item \texttt{test\_parser\_basic.cpp} --- простые конструкции (терминалы, нетерминалы, последовательности)
    \item \texttt{test\_parser\_or.cpp} --- альтернативы различной сложности
    \item \texttt{test\_parser\_iteration.cpp} --- итерации (унарные, бинарные)
    \item \texttt{test\_parser\_complex.cpp} --- вложенные конструкции
\end{itemize}

\textbf{Категория regex} --- тесты классов регулярных выражений, представленные ниже.

\begin{itemize}
    \item \texttt{test\_retree.cpp} --- методы базового класса
    \item \texttt{test\_reand.cpp} --- операция последовательности
    \item \texttt{test\_reor.cpp} --- операция альтернативы
    \item \texttt{test\_reiteration.cpp} --- операция итерации
\end{itemize}

\textbf{Категория transform} --- тесты преобразований грамматик, представленные ниже.

\begin{itemize}
    \item \texttt{test\_left\_elimination.cpp} --- устранение левой рекурсии
    \item \texttt{test\_left\_factorization.cpp} --- левая факторизация
    \item \texttt{test\_remove\_useless.cpp} --- удаление бесполезных символов
    \item \texttt{test\_first\_follow.cpp} --- вычисление FIRST/FOLLOW
\end{itemize}

\textbf{Категория analysis} --- тесты анализа грамматик, представленные ниже.

\begin{itemize}
    \item \texttt{test\_parsing\_table.cpp} --- построение таблиц разбора
    \item \texttt{test\_ll1\_check.cpp} --- проверка LL(1)-свойства
\end{itemize}

\subsubsection{Запуск тестов}

Система сборки поддерживает несколько способов запуска тестов.

Запуск всех тестов.
\begin{verbatim}
ctest --output-on-failure
cmake --build . --target run_all_tests
\end{verbatim}

Запуск по категории.
\begin{verbatim}
cmake --build . --target test_category_parser
ctest -L parser --output-on-failure
\end{verbatim}

Повторный запуск провалившихся тестов.
\begin{verbatim}
cmake --build . --target test_failed
\end{verbatim}

Параллельное выполнение тестов.
\begin{verbatim}
ctest --output-on-failure -j 8
\end{verbatim}

\subsubsection{Результаты тестирования}

На момент завершения работы все 18 тестовых модулей (более 120 индивидуальных тестов) успешно проходят на следующих платформах, представленных ниже.

\begin{itemize}
    \item Windows 10/11 --- MSVC 2022, MinGW-w64 (GCC 13.2.0)
    \item Linux (Ubuntu 22.04) --- GCC 11.4.0, Clang 14.0.0
    \item macOS (Ventura) --- Apple Clang 15.0.0
\end{itemize}

Время выполнения всех тестов составляет менее 2 секунд на современном оборудовании (Intel Core i9 12900h, 24 ГБ RAM DDR5-4800).

\subsection{Итоговая структура проекта}

Финальная структура директорий проекта представлена ниже.

\begin{verbatim}
SynGT_CPP/
├── libsyngt/               # Основная библиотека
│   ├── include/syngt/      # Публичные заголовки
│   │   ├── core/           # Базовые классы
│   │   ├── regex/          # Регулярные выражения
│   │   ├── parser/         # Парсер RBNF
│   │   ├── graphics/       # Графические объекты
│   │   ├── transform/      # Преобразования
│   │   ├── analysis/       # Анализ грамматик
│   │   └── utils/          # Утилиты
│   └── src/                # Реализация
├── syngt_cli/              # Консольное приложение
│   └── main.cpp
├── syngt_gui/              # Графическое приложение
│   ├── main.cpp
│   └── imgui/              # Dear ImGui (git submodule)
├── tests/                  # Модульные тесты
│   ├── core/
│   ├── parser/
│   ├── regex/
│   ├── transform/
│   └── analysis/
├── examples/               # Примеры использования
│   └── grammars/           # Тестовые грамматики
├── setup.bat               # Автоматический скрипт для установки ImGui
├── CMakeLists.txt          # Корневой файл сборки
└── README.md               # Документация проекта
\end{verbatim}

Такая организация обеспечивает чёткое разделение компонентов, упрощает навигацию по коду и позволяет собирать отдельные части проекта независимо (например, только библиотеку без GUI). Итоговый проект лежит в Git репозитории~\cite{my}.