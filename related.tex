% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}

\subsection{Контекст исследования}

Операция умножения матриц общего вида (GEMM) является критически важным компонентом многих вычислительных приложений. Для её эффективной реализации на GPU используются различные программные интерфейсы, среди которых выделяются два основных подхода: проприетарная технология CUDA от NVIDIA и открытый стандарт OpenCL.

OpenCL обеспечивает переносимость кода между устройствами различных производителей, что делает его привлекательным выбором для разработки кросс-платформенных решений. Однако эффективность реализаций GEMM на OpenCL сильно зависит от аппаратной платформы и применённых техник оптимизации.

В контексте активного развития высокопроизводительных вычислений на архитектуре RISC-V появление новых платформ с поддержкой OpenCL открывает обширное поле для исследований, производительность которых пока изучена недостаточно. Ключевым аспектом, определяющим эффективность различных оптимизаций, становится широкое использование графических процессоров компании Imagination Technologies в экосистеме RISC-V. Понимание того, какие программные оптимизации эффективны именно для этой связки CPU и GPU, важно для будущего развития производительных и энергоэффективных решений.

Библиотека MyGEMM предоставляет набор последовательно оптимизируемых реализаций GEMM с открытым исходным кодом, что делает её удобным инструментом для экспериментального исследования влияния различных оптимизаций на производительность конкретного оборудования.

\subsection{Библиотека MyGEMM}

Работа основана на открытом туториале MyGEMM~\cite{nugteren2018mygemm}, который демонстрирует пошаговую оптимизацию умножения матриц на GPU. Туториал содержит описания 11 последовательных версий ядра (kernel), каждое из которых добавляет определённые оптимизации. Ниже приведено краткое описание каждой оптимизации по порядку.

Ядро 1 (myGEMM1) --- наивная реализация, где каждый поток вычисляет один элемент результирующей матрицы. Служит базовым примером для сравнения эффективности оптимизаций. Производительность крайне низкая из-за неэффективного использования памяти и отсутствия переиспользования данных.

Ядро 2 (myGEMM2) --- блочный алгоритм с использованием локальной памяти (tiled algorithm)~\cite{goto2008anatomy}. Вводится параметр $\text{TS}$ (tile size), определяющий размер блока матрицы. Каждая рабочая группа загружает блок размера $\text{TS} \times \text{TS}$ в локальную память, что позволяет многократно использовать данные и снижает количество обращений к глобальной памяти. Барьерная синхронизация обеспечивает корректность работы с общей локальной памятью.

Ядро 3 (myGEMM3) --- оптимизация использования кэша путём подсчёта нескольких элементов одним потоком. Вводятся параметры $\text{WPT}$ (work-per-thread) --- число элементов, вычисляемых одним потоком, а также $\text{RTS} = \text{TS}/\text{WPT}$ --- сокращённый размер рабочей группы. Это позволяет лучше использовать данные, загруженные в регистры, и повысить арифметическую интенсивность.

Ядро 4 (myGEMM4) --- двумерное блокирование в регистрах (2D register blocking). Вместо одного параметра $\text{WPT}$ вводятся два независимых параметра: $\text{WPTM}$ и $\text{WPTN}$ --- количество элементов, вычисляемых одним потоком по каждому измерению матрицы. Также вводятся параметры $\text{TSM}$ и $\text{TSN}$ --- размеры блоков по соответствующим измерениям. Это позволяет более гибко настроить алгоритм под архитектурные особенности процессора.

Ядро 5 (myGEMM5) --- транспонирование локальной памяти для улучшения паттерна доступа. Матрица $A$ загружается в локальную память с транспонированием, что обеспечивает более эффективные последовательные обращения к памяти при выполнении вычислений.

Ядро 6 (myGEMM6) --- векторизация операций загрузки/записи. Вводится параметр $\text{VW}$ (vector width) --- ширина вектора для загрузки данных. Использование векторных типов данных OpenCL позволяет за одну операцию загружать/записывать несколько элементов, что увеличивает пропускную способность памяти.

Ядро 7 (myGEMM7) --- выравнивание глобальной памяти. Обеспечивается правильное выравнивание (alignment) доступа, что необходимо для эффективной работы векторных операций загрузки и записи.

Ядро 8 (myGEMM8) --- двумерная регистровая блокировка (2D register blocking). Развивает идею ядра 6, добавляя более сложную организацию вычислений, при которой каждый поток обрабатывает прямоугольный блок элементов результирующей матрицы, кэшируя промежуточные данные в регистрах процессора.

Ядро 9 (myGEMM9) --- добавление программной предвыборки данных (software pre-fetching). Внедрена асинхронная загрузка данных с использованием двойного буфера в локальной памяти для перекрытия операций вычисления и доступа к памяти. Это позволяет уменьшить простой вычислительных блоков в ожидании данных.

Ядро 10 (myGEMM10) --- поддержка произвольных размеров матриц. Добавляет обработку граничных случаев (edge cases), когда размеры матриц не кратны размерам блоков, обеспечивая корректную работу для матриц любых размеров.

Ядро 11 (myGEMM11) --- реализация алгоритма на основе регистрового тайлинга с использованием векторных типов данных. В отличие от предыдущих оптимизаций, активно использовавших локальную память и барьерную синхронизацию, данный подход минимизирует затраты на координацию потоков за счет полной загрузки данных непосредственно в регистры.

Каждая последующая оптимизация в туториале демонстрирует улучшение производительности на дискретных GPU NVIDIA. Однако эффективность этих оптимизаций на RISC-V платформах с интегрированными GPU может существенно отличаться, что и является предметом данного исследования.

\subsection{Конфигурационные параметры ядер}

Различные ядра MyGEMM используют различные наборы параметров для настройки производительности. Ниже приведено описание основных параметров оптимизации.

\subsubsection{Параметры базовых ядер (1--3)}

TS (Tile Size) --- размер квадратного блока матрицы, загружаемого в локальную память рабочей группой. Определяет размер рабочей группы ($\text{TS} \times \text{TS}$ потоков) и объём используемой локальной памяти ($2 \times \text{TS}^2$ элементов типа float). Большие значения увеличивают переиспользование данных, но требуют больше локальной памяти и могут снизить заполнение (occupancy).

WPT (Work Per Thread) --- количество элементов результирующей матрицы, вычисляемых одним потоком (используется в ядре 3). При увеличении WPT размер рабочей группы сокращается до $\text{RTS} = \text{TS}/\text{WPT}$ потоков на измерение, что позволяет лучше использовать регистры и повысить арифметическую интенсивность.

\subsubsection{Параметры продвинутых ядер (4--10)}

TSM и TSN --- размеры блоков локальной памяти по измерениям $M$ и $N$ соответственно. Обобщают параметр TS для асимметричных блоков, позволяя независимо настраивать размеры по каждому измерению. Размер рабочей группы определяется как $\frac{\text{TSM}}{\text{WPTM}} \times \frac{\text{TSN}}{\text{WPTN}}$ потоков.

WPTM и WPTN --- количество элементов результирующей матрицы, вычисляемых одним потоком по измерениям $M$ и $N$ соответственно. Двумерное обобщение параметра WPT. Каждый поток вычисляет прямоугольный блок размером $\text{WPTM} \times \text{WPTN}$ элементов.

VW (Vector Width) --- ширина вектора для операций загрузки и записи данных (используется в ядрах 6--10). Определяет количество элементов, загружаемых/записываемых одной векторной операцией. Типичные значения: 1, 2, 4, 8, 16. Требует, чтобы TSM, TSN, WPTM, WPTN были кратны VW. Увеличение VW повышает пропускную способность памяти, но может снизить гибкость конфигурации.

\subsubsection{Параметры ядра 11 (clBLAS-подход)}

Ядро 11 использует принципиально иной набор параметров, не связанный с локальной памятью.

RX и RY --- размеры 2D регистрового блока, обрабатываемого одним потоком. RX определяет количество элементов по измерению, соответствующему матрице $A$, RY --- по измерению матрицы $B$. В оригинальной реализации clBLAS используются значения RX = 8, RY = 4, соответствующие векторным типам float8 и float4.

RK --- размер блока по измерению $K$ (глубина матриц при умножении). Определяет количество итераций внутреннего цикла накопления до загрузки новой порции данных. В стандартной конфигурации RK = RY = 4, что позволяет эффективно переиспользовать данные матрицы $B$.

Размер рабочей группы в ядре 11 фиксирован и не зависит от параметров: 8×8 = 64 потока в оригинальной реализации clBLAS, либо настраиваемый параметр в модифицированных версиях.

\subsection{Библиотека CLBlast}

CLBlast~\cite{clblast} --- современная высокопроизводительная библиотека базовых операций линейной алгебры (BLAS) для OpenCL, разработанная Cedric Nugteren. В отличие от учебной библиотеки MyGEMM, CLBlast — это полнофункциональная библиотека, предназначенная для практического применения.

\subsubsection{Основные характеристики}

CLBlast реализует практически полный набор операций BLAS уровней 1, 2 и 3, включая операцию умножения матриц общего вида (GEMM). Библиотека спроектирована с акцентом на переносимость и производительность, обеспечивая эффективную работу на широком спектре устройств с поддержкой OpenCL --- от встроенных GPU до дискретных графических ускорителей профессионального уровня.

Ключевые особенности CLBlast представлены ниже.

\begin{itemize}
    \item \textbf{Кросс-платформенность}: работа на GPU различных производителей (NVIDIA, AMD, Intel, ARM Mali, Imagination PowerVR) через единый интерфейс OpenCL.
    \item \textbf{Автоматический тюнинг}: встроенная система автоматической оптимизации параметров под конкретную аппаратную платформу.
    \item \textbf{Открытый исходный код}: распространяется под лицензией Apache 2.0, что обеспечивает прозрачность реализации и возможность модификации.
\end{itemize}

\subsubsection{Механизм автоматического тюнинга}

CLBlast отличается от MyGEMM встроенной системой автоматической настройки производительности. Библиотека поставляется с базой предварительно оптимизированных конфигураций для наиболее распространённых GPU, однако для достижения максимальной производительности на новых или нестандартных платформах необходимо провести процедуру тюнинга.

Процесс тюнинга представляет собой систематический перебор значений конфигурационных параметров с измерением производительности на реальном оборудовании. Для операции GEMM автотюнер варьирует основные параметры, пердставленные ниже.

\begin{itemize}
    \item \textbf{MWG, NWG, KWG} --- размеры рабочих групп по измерениям M, N и K.
    \item \textbf{MDIMC, NDIMC} --- количество потоков на измерение внутри рабочей группы.
    \item \textbf{MDIMA, NDIMB} --- параметры загрузки данных из глобальной памяти.
    \item \textbf{KWI} --- количество итераций внутреннего цикла.
    \item \textbf{VWM, VWN} --- ширина векторизации операций по измерениям M и N.
    \item \textbf{STRM, STRN} --- параметры использования локальной памяти.
    \item \textbf{SA, SB} --- стратегии кэширования матриц A и B.
\end{itemize}

Автотюнер использует алгоритмы поиска в пространстве параметров для выявления оптимальных конфигураций, минимизируя время выполнения операции при соблюдении аппаратных ограничений (размер локальной памяти, максимальный размер рабочей группы, количество регистров).

\subsubsection{Отличия от MyGEMM}

Основные различия CLBlast и MyGEMM приведены в таблице~\ref{tab:mygemm_vs_clblast}.

\begin{table}[h]
\centering
\caption{Сравнение библиотек MyGEMM и CLBlast}
\label{tab:mygemm_vs_clblast}
\begin{tabular}{p{0.45\textwidth}p{0.45\textwidth}}
\hline
\textbf{MyGEMM} & \textbf{CLBlast} \\
\hline
Учебная библиотека, демонстрирующая пошаговую оптимизацию & Отпимизированная библиотека для использования в производительных решениях \\
\hline
11 отдельных ядер с нарастающей сложностью оптимизаций & Единое универсальное ядро с адаптивными параметрами \\
\hline
Ручная настройка параметров для каждой платформы & Автоматический поиск оптимальных параметров \\
\hline
Фокус на понимании принципов оптимизации & Фокус на максимальной производительности \\
\hline
\end{tabular}
\end{table}

Если MyGEMM демонстрирует пошаговые оптимизации для обучения, то CLBlast предоставляет готовое решение для практического применения в задачах линейной алгебры.