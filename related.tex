% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}

\subsection{Контекст исследования}

Операция умножения матриц общего вида (GEMM) является критически важным компонентом многих вычислительных приложений. Для её эффективной реализации на GPU используются различные программные интерфейсы, среди которых выделяются два основных подхода: проприетарная технология CUDA от NVIDIA и открытый стандарт OpenCL.

OpenCL обеспечивает переносимость кода между устройствами различных производителей, что делает его привлекательным выбором для разработки кросс-платформенных решений. Однако эффективность реализаций GEMM на OpenCL сильно зависит от аппаратной платформы и применённых техник оптимизации.

В контексте развития архитектуры RISC-V появляются новые вычислительные платформы с поддержкой OpenCL, производительность которых остаётся малоисследованной. Понимание того, какие оптимизации эффективны на таких платформах, критически важно для разработки.

Библиотека MyGEMM предоставляет набор последовательно оптимизируемых реализаций GEMM с открытым исходным кодом, что делает её удобным инструментом для экспериментального исследования влияния различных оптимизаций на производительность конкретного оборудования.

\subsection{Библиотека MyGEMM}

Данная работа базируется на открытом туториале MyGEMM~\cite{nugteren2018mygemm}, который демонстрирует пошаговую оптимизацию умножения матриц на GPU. Туториал содержит описания 11 последовательных версий ядра (kernel), каждое из которых добавляет определённые оптимизации. Ниже приведено краткое описание каждого ядра:

\textbf{Ядро 1 (myGEMM1)} --- наивная реализация, где каждый поток вычисляет один элемент результирующей матрицы. Служит базовым примером для сравнения эффективности оптимизаций. Производительность крайне низкая из-за неэффективного использования памяти и отсутствия переиспользования данных.

\textbf{Ядро 2 (myGEMM2)} --- блочный алгоритм с использованием локальной памяти (tiled algorithm)~\cite{goto2008anatomy}. Вводится параметр $\text{TS}$ (tile size), определяющий размер блока матрицы. Каждая рабочая группа загружает блок размера $\text{TS} \times \text{TS}$ в локальную память, что позволяет многократно использовать данные и снижает количество обращений к глобальной памяти. Барьерная синхронизация обеспечивает корректность работы с общей локальной памятью.

\textbf{Ядро 3 (myGEMM3)} --- оптимизация использования кэша путём подсчёта нескольких элементов одним потоком. Вводятся параметры $\text{WPT}$ (work-per-thread) --- число элементов, вычисляемых одним потоком, а также $\text{RTS} = \text{TS}/\text{WPT}$ --- сокращённый размер рабочей группы. Это позволяет лучше использовать данные, загруженные в регистры, и повысить арифметическую интенсивность.

\textbf{Ядро 4 (myGEMM4)} --- двумерное блокирование в регистрах (2D register blocking). Вместо одного параметра $\text{WPT}$ вводятся два независимых параметра: $\text{WPTM}$ и $\text{WPTN}$ --- количество элементов, вычисляемых одним потоком по каждому измерению матрицы. Также вводятся параметры $\text{TSM}$ и $\text{TSN}$ --- размеры блоков по соответствующим измерениям. Это позволяет более гибко настроить алгоритм под архитектурные особенности процессора.

\textbf{Ядро 5 (myGEMM5)} --- транспонирование локальной памяти для улучшения паттерна доступа. Матрица $A$ загружается в локальную память с транспонированием, что обеспечивает более эффективные последовательные обращения к памяти при выполнении вычислений.

\textbf{Ядро 6 (myGEMM6)} --- векторизация операций загрузки/записи. Вводится параметр $\text{VW}$ (vector width) --- ширина вектора для загрузки данных. Использование векторных типов данных OpenCL позволяет за одну операцию загружать/записывать несколько элементов, что увеличивает пропускную способность памяти.

\textbf{Ядро 7 (myGEMM7)} --- выравнивание глобальной памяти. Обеспечивается правильное выравнивание (alignment) доступа к глобальной памяти, что критично для эффективной работы векторных операций загрузки и записи.

\textbf{Ядро 8 (myGEMM8)} --- двумерная регистровая блокировка (2D register blocking). Развивает идею ядра 6, добавляя более сложную организацию вычислений, при которой каждый поток обрабатывает прямоугольный блок элементов результирующей матрицы, кэшируя промежуточные данные в регистрах процессора.

\textbf{Ядро 9 (myGEMM9)} --- добавление программной предвыборки данных (software pre-fetching). Использует техники асинхронной загрузки данных для сокрытия латентности обращений к памяти за счёт перекрытия загрузки следующего блока данных с вычислениями над текущим.

\textbf{Ядро 10 (myGEMM10)} --- поддержка произвольных размеров матриц. Добавляет обработку граничных случаев (edge cases), когда размеры матриц не кратны размерам блоков, обеспечивая корректную работу для матриц любых размеров.

\textbf{Ядро 11 (myGEMM11)} --- реализация подхода clBLAS~\cite{clblas2015}. В отличие от всех предыдущих ядер, это ядро \textbf{не использует локальную память}, полностью полагаясь на регистровую блокировку и векторные типы данных. Основные особенности:

\begin{itemize}
    \item Фиксированный малый размер рабочей группы (8×8 потоков);
    \item Использование векторных типов данных OpenCL (float8 для матрицы $A$, float4 для матрицы $B$);
    \item 2D регистровая блокировка с параметрами RX, RY, RK, определяющими размеры блока, обрабатываемого одним потоком;
    \item Прямая загрузка векторов данных из глобальной памяти в регистры процессора без промежуточного использования локальной памяти;
    \item Выполнение множественных операций умножения-сложения (FMA) над данными в регистрах перед загрузкой новой порции данных.
\end{itemize}

Каждое последующее ядро в туториале демонстрирует улучшение производительности на дискретных GPU NVIDIA. Однако эффективность этих оптимизаций на RISC-V платформах с интегрированными GPU может существенно отличаться, что и является предметом данного исследования.

\subsection{Конфигурационные параметры ядер}

Различные ядра MyGEMM используют различные наборы параметров для настройки производительности. Ниже приведено описание основных параметров оптимизации.

\subsubsection{Параметры базовых ядер (1--3)}

\textbf{TS (Tile Size)} --- размер квадратного блока матрицы, загружаемого в локальную память рабочей группой. Определяет размер рабочей группы ($\text{TS} \times \text{TS}$ потоков) и объём используемой локальной памяти ($2 \times \text{TS}^2$ элементов типа float). Большие значения увеличивают переиспользование данных, но требуют больше локальной памяти и могут снизить заполнение (occupancy).

\textbf{WPT (Work Per Thread)} --- количество элементов результирующей матрицы, вычисляемых одним потоком (используется в ядре 3). При увеличении WPT размер рабочей группы сокращается до $\text{RTS} = \text{TS}/\text{WPT}$ потоков на измерение, что позволяет лучше использовать регистры и повысить арифметическую интенсивность.

\subsubsection{Параметры продвинутых ядер (4--10)}

\textbf{TSM и TSN} --- размеры блоков локальной памяти по измерениям $M$ и $N$ соответственно. Обобщают параметр TS для асимметричных блоков, позволяя независимо настраивать размеры по каждому измерению. Размер рабочей группы определяется как $\frac{\text{TSM}}{\text{WPTM}} \times \frac{\text{TSN}}{\text{WPTN}}$ потоков.

\textbf{WPTM и WPTN} --- количество элементов результирующей матрицы, вычисляемых одним потоком по измерениям $M$ и $N$ соответственно. Двумерное обобщение параметра WPT. Каждый поток вычисляет прямоугольный блок размером $\text{WPTM} \times \text{WPTN}$ элементов.

\textbf{VW (Vector Width)} --- ширина вектора для операций загрузки и записи данных (используется в ядрах 6--10). Определяет количество элементов, загружаемых/записываемых одной векторной операцией. Типичные значения: 1, 2, 4, 8, 16. Требует, чтобы TSM, TSN, WPTM, WPTN были кратны VW. Увеличение VW повышает пропускную способность памяти, но может снизить гибкость конфигурации.

\subsubsection{Параметры ядра 11 (clBLAS-подход)}

Ядро 11 использует принципиально иной набор параметров, не связанный с локальной памятью:

\textbf{RX и RY} --- размеры 2D регистрового блока, обрабатываемого одним потоком. RX определяет количество элементов по измерению, соответствующему матрице $A$, RY --- по измерению матрицы $B$. В оригинальной реализации clBLAS используются значения RX = 8, RY = 4, соответствующие векторным типам float8 и float4.

\textbf{RK} --- размер блока по измерению $K$ (глубина матриц при умножении). Определяет количество итераций внутреннего цикла накопления до загрузки новой порции данных. В стандартной конфигурации RK = RY = 4, что позволяет эффективно переиспользовать данные матрицы $B$.

Размер рабочей группы в ядре 11 фиксирован и не зависит от параметров: 8×8 = 64 потока в оригинальной реализации clBLAS, либо настраиваемый параметр в модифицированных версиях.

\subsection{Аппаратные платформы}

Для экспериментов используются два устройства на базе архитектуры RISC-V и одно устройство для сравнения на базе x86-64.

\subsubsection{Banana Pi BPI-F3}

Одноплатный компьютер на базе процессора SpacemiT K1~\cite{spacemit2024}~\cite{bananapi_f3_wiki} — восьмиядерного RISC-V процессора архитектуры RV64GCV с частотой до 2.0~ГГц. Процессор поддерживает векторное расширение (V). Платформа оснащена 16~ГБ памяти типа LPDDR4/4X-2666. Графическое ядро — IMG BXE-2-32 с поддержкой OpenCL 3.0, OpenGL ES 3.2 и Vulkan 1.2.

\subsubsection{StarFive VisionFive 2}

Одноплатная система на основе SoC JH7110~\cite{starfive2023datasheet}~\cite{visionfive2_wiki} компании StarFive, содержащего четыре ядра RISC-V SiFive U74 с архитектурой RV64GC и тактовой частотой до 1.5~ГГц. Платформа включает 8~ГБ памяти LPDDR4-2800. Графическое ядро — IMG BXE-4-32 MC1 с поддержкой OpenCL 3.0, OpenGL ES 3.2 и Vulkan 1.2.

\subsubsection{ASUS ROG Zephyrus M16}

Ноутбук на базе Intel Core i9-12900H. Процессор содержит 14 ядер гибридной архитектуры (6 производительных P-cores и 8 энергоэффективных E-cores) с максимальной тактовой частотой до 5.0 ГГц. Встроенное графическое ядро Intel Iris Xe Graphics поддерживает OpenCL 3.0 и содержит 96 исполнительных блоков (Execution Units). Система оснащена 24 ГБ памяти DDR5-4800.

Следует отметить, что ноутбук также оснащён дискретной видеокартой, однако в рамках данного исследования она не использовалась. Все измерения проводились исключительно на встроенной графике Intel Iris Xe для обеспечения сравнения производительности именно встроенных GPU решений различных архитектур.

\subsubsection{Программное обеспечение}

RISC-V платформы работают под управлением Debian 12 (Bookworm). На Banana Pi BPI-F3 используется ядро Linux 6.1.15, на StarFive VisionFive 2~— Linux 5.15 LTS. Поддержка OpenCL версии 3.0 на RISC-V обеспечивается драйверами Imagination Technologies~\cite{img_opencl} для графических ядер IMG BXE.

Платформа на x86-64 работает под управлением Manjaro Linux с драйверами Intel Graphics версии 31.0.101.4255. Поддержка OpenCL 3.0 обеспечивается встроенными драйверами Intel для Iris Xe Graphics.

Для компиляции библиотеки MyGEMM на всех платформах использовался компилятор GCC версии 13.