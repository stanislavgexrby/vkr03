% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}

\subsection{Контекст исследования}

Операция умножения матриц общего вида (GEMM) является критически важным компонентом многих вычислительных приложений. Для её эффективной реализации на GPU используются различные программные интерфейсы, среди которых выделяются два основных подхода: проприетарная технология CUDA от NVIDIA и открытый стандарт OpenCL.

OpenCL обеспечивает переносимость кода между устройствами различных производителей, что делает его привлекательным выбором для разработки кросс-платформенных решений. Однако эффективность реализаций GEMM на OpenCL сильно зависит от аппаратной платформы и применённых техник оптимизации.

В контексте развития архитектуры RISC-V появляются новые вычислительные платформы с поддержкой OpenCL, производительность которых остаётся малоисследованной. Понимание того, какие оптимизации эффективны на таких платформах, критически важно для будущего развития эффективных и производительных решений.

Библиотека MyGEMM предоставляет набор последовательно оптимизируемых реализаций GEMM с открытым исходным кодом, что делает её удобным инструментом для экспериментального исследования влияния различных оптимизаций на производительность конкретного оборудования.

\subsection{Библиотека MyGEMM}

Данная работа базируется на открытом туториале MyGEMM~\cite{nugteren2018mygemm}, который демонстрирует пошаговую оптимизацию умножения матриц на GPU. Туториал содержит описания 11 последовательных версий ядра (kernel), каждое из которых добавляет определённые оптимизации. Ниже приведено краткое описание каждого ядра:

\textbf{Ядро 1 (myGEMM1)} --- наивная реализация, где каждый поток вычисляет один элемент результирующей матрицы. Служит базовым примером для сравнения эффективности оптимизаций. Производительность крайне низкая из-за неэффективного использования памяти и отсутствия переиспользования данных.

\textbf{Ядро 2 (myGEMM2)} --- блочный алгоритм с использованием локальной памяти (tiled algorithm)~\cite{goto2008anatomy}. Вводится параметр $\text{TS}$ (tile size), определяющий размер блока матрицы. Каждая рабочая группа загружает блок размера $\text{TS} \times \text{TS}$ в локальную память, что позволяет многократно использовать данные и снижает количество обращений к глобальной памяти. Барьерная синхронизация обеспечивает корректность работы с общей локальной памятью.

\textbf{Ядро 3 (myGEMM3)} --- оптимизация использования кэша путём подсчёта нескольких элементов одним потоком. Вводятся параметры $\text{WPT}$ (work-per-thread) --- число элементов, вычисляемых одним потоком, а также $\text{RTS} = \text{TS}/\text{WPT}$ --- сокращённый размер рабочей группы. Это позволяет лучше использовать данные, загруженные в регистры, и повысить арифметическую интенсивность.

\textbf{Ядро 4 (myGEMM4)} --- двумерное блокирование в регистрах (2D register blocking). Вместо одного параметра $\text{WPT}$ вводятся два независимых параметра: $\text{WPTM}$ и $\text{WPTN}$ --- количество элементов, вычисляемых одним потоком по каждому измерению матрицы. Также вводятся параметры $\text{TSM}$ и $\text{TSN}$ --- размеры блоков по соответствующим измерениям. Это позволяет более гибко настроить алгоритм под архитектурные особенности процессора.

\textbf{Ядро 5 (myGEMM5)} --- транспонирование локальной памяти для улучшения паттерна доступа. Матрица $A$ загружается в локальную память с транспонированием, что обеспечивает более эффективные последовательные обращения к памяти при выполнении вычислений.

\textbf{Ядро 6 (myGEMM6)} --- векторизация операций загрузки/записи. Вводится параметр $\text{VW}$ (vector width) --- ширина вектора для загрузки данных. Использование векторных типов данных OpenCL позволяет за одну операцию загружать/записывать несколько элементов, что увеличивает пропускную способность памяти.

\textbf{Ядро 7 (myGEMM7)} --- выравнивание глобальной памяти. Обеспечивается правильное выравнивание (alignment) доступа к глобальной памяти, что критично для эффективной работы векторных операций загрузки и записи.

\textbf{Ядро 8 (myGEMM8)} --- двумерная регистровая блокировка (2D register blocking). Развивает идею ядра 6, добавляя более сложную организацию вычислений, при которой каждый поток обрабатывает прямоугольный блок элементов результирующей матрицы, кэшируя промежуточные данные в регистрах процессора.

\textbf{Ядро 9 (myGEMM9)} --- добавление программной предвыборки данных (software pre-fetching). Использует техники асинхронной загрузки данных для сокрытия латентности обращений к памяти за счёт перекрытия загрузки следующего блока данных с вычислениями над текущим.

\textbf{Ядро 10 (myGEMM10)} --- поддержка произвольных размеров матриц. Добавляет обработку граничных случаев (edge cases), когда размеры матриц не кратны размерам блоков, обеспечивая корректную работу для матриц любых размеров.

\textbf{Ядро 11 (myGEMM11)} --- реализация подхода clBLAS~\cite{clblas2015}. В отличие от всех предыдущих ядер, это ядро \textbf{не использует локальную память}, полностью полагаясь на регистровую блокировку и векторные типы данных. Основные особенности:

\begin{itemize}
    \item Фиксированный малый размер рабочей группы (8×8 потоков);
    \item Использование векторных типов данных OpenCL (float8 для матрицы $A$, float4 для матрицы $B$);
    \item 2D регистровая блокировка с параметрами RX, RY, RK, определяющими размеры блока, обрабатываемого одним потоком;
    \item Прямая загрузка векторов данных из глобальной памяти в регистры процессора без промежуточного использования локальной памяти;
    \item Выполнение множественных операций умножения-сложения (FMA) над данными в регистрах перед загрузкой новой порции данных.
\end{itemize}

Каждое последующее ядро в туториале демонстрирует улучшение производительности на дискретных GPU NVIDIA. Однако эффективность этих оптимизаций на RISC-V платформах с интегрированными GPU может существенно отличаться, что и является предметом данного исследования.

\subsection{Конфигурационные параметры ядер}

Различные ядра MyGEMM используют различные наборы параметров для настройки производительности. Ниже приведено описание основных параметров оптимизации.

\subsubsection{Параметры базовых ядер (1--3)}

\textbf{TS (Tile Size)} --- размер квадратного блока матрицы, загружаемого в локальную память рабочей группой. Определяет размер рабочей группы ($\text{TS} \times \text{TS}$ потоков) и объём используемой локальной памяти ($2 \times \text{TS}^2$ элементов типа float). Большие значения увеличивают переиспользование данных, но требуют больше локальной памяти и могут снизить заполнение (occupancy).

\textbf{WPT (Work Per Thread)} --- количество элементов результирующей матрицы, вычисляемых одним потоком (используется в ядре 3). При увеличении WPT размер рабочей группы сокращается до $\text{RTS} = \text{TS}/\text{WPT}$ потоков на измерение, что позволяет лучше использовать регистры и повысить арифметическую интенсивность.

\subsubsection{Параметры продвинутых ядер (4--10)}

\textbf{TSM и TSN} --- размеры блоков локальной памяти по измерениям $M$ и $N$ соответственно. Обобщают параметр TS для асимметричных блоков, позволяя независимо настраивать размеры по каждому измерению. Размер рабочей группы определяется как $\frac{\text{TSM}}{\text{WPTM}} \times \frac{\text{TSN}}{\text{WPTN}}$ потоков.

\textbf{WPTM и WPTN} --- количество элементов результирующей матрицы, вычисляемых одним потоком по измерениям $M$ и $N$ соответственно. Двумерное обобщение параметра WPT. Каждый поток вычисляет прямоугольный блок размером $\text{WPTM} \times \text{WPTN}$ элементов.

\textbf{VW (Vector Width)} --- ширина вектора для операций загрузки и записи данных (используется в ядрах 6--10). Определяет количество элементов, загружаемых/записываемых одной векторной операцией. Типичные значения: 1, 2, 4, 8, 16. Требует, чтобы TSM, TSN, WPTM, WPTN были кратны VW. Увеличение VW повышает пропускную способность памяти, но может снизить гибкость конфигурации.

\subsubsection{Параметры ядра 11 (clBLAS-подход)}

Ядро 11 использует принципиально иной набор параметров, не связанный с локальной памятью:

\textbf{RX и RY} --- размеры 2D регистрового блока, обрабатываемого одним потоком. RX определяет количество элементов по измерению, соответствующему матрице $A$, RY --- по измерению матрицы $B$. В оригинальной реализации clBLAS используются значения RX = 8, RY = 4, соответствующие векторным типам float8 и float4.

\textbf{RK} --- размер блока по измерению $K$ (глубина матриц при умножении). Определяет количество итераций внутреннего цикла накопления до загрузки новой порции данных. В стандартной конфигурации RK = RY = 4, что позволяет эффективно переиспользовать данные матрицы $B$.

Размер рабочей группы в ядре 11 фиксирован и не зависит от параметров: 8×8 = 64 потока в оригинальной реализации clBLAS, либо настраиваемый параметр в модифицированных версиях.