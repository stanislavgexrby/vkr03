% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}

\subsection{Контекст исследования}

Инструменты для работы с формальными грамматиками играют важную роль в разработке компиляторов, интерпретаторов и систем анализа языков программирования. Визуализация синтаксических правил в форме диаграмм, подобных диаграммам Вирта~\cite{wirth1977syntax}, существенно упрощает понимание структуры языка как для разработчиков, так и для пользователей.

В конце 1990-х годов на кафедре информатики СПбГУ была разработана инструментальная система SynGT для построения и визуализации управляющих граф-схем по RBNF-грамматикам. Система была реализована на языке Object Pascal и демонстрировала эффективный подход к автоматической генерации синтаксических диаграмм. Однако с течением времени технологическая база системы устарела: язык Pascal имеет ограниченную экосистему, слабую интеграцию с современными инструментами разработки и затруднённую поддержку на актуальных операционных системах.

Актуальность портирования SynGT на современный язык программирования обусловлена необходимостью сохранения и развития методологии визуализации формальных грамматик, а также обеспечения доступности инструмента для современных процессов разработки, включающих непрерывную интеграцию, контейнеризацию и кросс-платформенность.

\subsection{Система SynGT}

SynGT (Syntax Graph Tool) — инструментальная система для автоматического построения синтаксических диаграмм по RBNF-грамматикам. Система предоставляет графический интерфейс для создания, редактирования и визуализации формальных грамматик в виде интуитивно понятных диаграмм, аналогичных диаграммам Вирта (railroad diagrams).

\subsubsection{Функциональные возможности}

Исходная система SynGT предоставляет следующие возможности.

\begin{itemize}
    \item \textbf{Загрузка грамматик}: открытие файлов, загрузка грамматики с помощью GEdit и Syntax.
    \item \textbf{Редактирование грамматик}: текстовый редактор с синтаксисом RBNF для определения нетерминалов, терминалов, семантических действий и вспомогательных определений (макросов).
    \item \textbf{Автоматическая визуализация}: построение синтаксических диаграмм с автоматическим размещением графических элементов.
    \item \textbf{Интерактивное редактирование}: возможность выделения, перемещения и модификации элементов диаграммы.
    \item \textbf{Анализ грамматик}: проверка на LL(1)-свойства, вычисление FIRST и FOLLOW множеств.
    \item \textbf{Преобразования грамматик}: устранение левой, центральной, правой рекурсии, левая факторизация, раскрытие макросов.
    \item \textbf{Экспорт результатов}: сохранение диаграмм в графические форматы и генерация таблиц разбора.
\end{itemize}

\subsubsection{Архитектура системы SynGT}

Система SynGT реализована на языке Object Pascal (Borland Delphi) и состоит из следующих основных компонентов.

\begin{itemize}
    \item \textbf{Модуль грамматики} (Grammar): управление списками терминалов, нетерминалов, семантических действий и макросов.
    \item \textbf{Парсер RBNF} (Parser): рекурсивный спуск для разбора текстовых определений грамматик.
    \item \textbf{Представление регулярных выражений} (RegularExpression): иерархия классов для представления синтаксических деревьев (терминалы, нетерминалы, операции AND, OR, итерации).
    \item \textbf{Система визуализации} (DrawObject, Creator): алгоритмы преобразования деревьев регулярных выражений в графические объекты с автоматическим размещением.
    \item \textbf{Модули анализа и преобразований}: вычисление FIRST/FOLLOW множеств, проверка LL(1), устранение левой рекурсии, факторизация.
    \item \textbf{Графический интерфейс} (Main, Child): интерфейс для работы с несколькими грамматиками одновременно.
\end{itemize}

\subsection{Формат RBNF-грамматик}

RBNF (Regular Backus-Naur Form) представляет собой расширенную форму Бэкуса-Наура с регулярными операторами, позволяющую более компактно описывать синтаксические правила языков программирования.

\subsubsection{Синтаксис RBNF}

Грамматика в формате RBNF состоит из набора правил следующего вида.
\begin{verbatim}
Нетерминал : Правило.
\end{verbatim}

где правило представляет собой регулярное выражение над терминалами и нетерминалами.

\textbf{Элементы грамматики}

\begin{itemize}
    \item \textbf{Терминалы} --- заключаются в одинарные кавычки, например: \texttt{'if'}, \texttt{'begin'}, \texttt{'+'}.
    \item \textbf{Нетерминалы} --- идентификаторы, начинающиеся с буквы, например: \texttt{stmt}, \texttt{expr}, \texttt{ID}.
    \item \textbf{Макросы} --- именованные подвыражения для переиспользования, обозначаются символом \texttt{@}, например: \texttt{@list}.
    \item \textbf{Семантические действия} --- специальные маркеры для связи с семантическим анализатором, обозначаются символом \texttt{\#\#}.
\end{itemize}

\subsubsection{Операторы RBNF}

\textbf{Последовательность} (запятая \texttt{,}) --- элементы следуют один за другим.
\begin{verbatim}
stmt : 'begin' , stmtlist , 'end'.
\end{verbatim}

\textbf{Альтернатива} (точка с запятой \texttt{;}) --- выбор одного из нескольких вариантов.
\begin{verbatim}
expr : term ; term , '+' , expr ; term , '-' , expr.
\end{verbatim}

\textbf{Унарная итерация} (звёздочка \texttt{*}) --- повторение ноль или более раз.
\begin{verbatim}
list : element , @*(element).
\end{verbatim}

\textbf{Положительная итерация} (плюс \texttt{+}) --- повторение один или более раз.
\begin{verbatim}
identifier : letter , @+(letter ; digit).
\end{verbatim}

\textbf{Бинарная итерация} (решётка \texttt{\#}) --- специальный оператор для описания циклов с телом и условием продолжения.
\begin{verbatim}
A : body # separator.
\end{verbatim}
Эквивалентно: \texttt{body , @*(separator , body)}.

\textbf{Группировка} (круглые скобки \texttt{(...)}) --- задание приоритета операций.
\begin{verbatim}
expr : term , @*(( '+' ; '-' ) , term).
\end{verbatim}

\subsubsection{Примеры грамматик}

\textbf{Простая грамматика для объявлений переменных.}
\begin{verbatim}
S : declarations.
declarations : declaration , @*(',' , declaration).
declaration : type , identifier.
type : 'int' ; 'float' ; 'string'.
identifier : ID.
\end{verbatim}

Данная грамматика описывает синтаксис объявления переменных, разделённых запятыми.
\begin{itemize}
\item \textbf{S} --- начальный символ грамматики, представляющий список объявлений.
\item \textbf{declarations} --- нетерминал, определяющий одно или несколько объявлений через запятую.
\item \textbf{@*(',' , declaration)} - конструкция, которая представляет итерацию с разделителем: ноль или более повторений \texttt{declaration}, разделённых запятой.
\item \textbf{declaration} --- состоит из типа и идентификатора.
\item \textbf{type} --- терминалы \texttt{'int'}, \texttt{'float'}, \texttt{'string'}.
\item \textbf{identifier} --- терминал \texttt{ID} (идентификатор).
\end{itemize}

Пример корректной цепочки: \texttt{int x, float y, string name}

\textbf{Грамматика с левой рекурсией (требует преобразования).}
\begin{verbatim}
expr : expr , '+' , term ; expr , '-' , term ; term.
term : term , '*' , factor ; term , '/' , factor ; factor.
factor : '(' , expr , ')' ; ID ; NUM.
\end{verbatim}

Эта грамматика описывает арифметические выражения с операциями разного приоритета. Особенности:
\begin{itemize}
\item Содержит \textbf{левую рекурсию} в правилах для \texttt{expr} и \texttt{term}, когда нетерминал ссылается на себя в начале правила.
\item Левая рекурсия создаёт проблемы для нисходящих анализаторов, так как приводит к бесконечной рекурсии.
\item Иерархия приоритетов: выражения (\texttt{expr}) $\rightarrow$ слагаемые (\texttt{term}) $\rightarrow$ множители (\texttt{factor}).
\item Операции: \texttt{+}, \texttt{-} (низший приоритет), \texttt{*}, \texttt{/} (высший приоритет).
\item \texttt{factor} представляет базовые элементы: идентификаторы (\texttt{ID}), числа (\texttt{NUM}) и выражения в скобках.
\end{itemize}

Пример корректного выражения: \texttt{a + b * (c - d)}

Для практического использования в синтаксических анализаторах такую грамматику необходимо преобразовать в эквивалентную без левой рекурсии.

\subsection{Алгоритм визуализации}

Ключевым аспектом системы SynGT является алгоритм автоматического построения синтаксических диаграмм из деревьев регулярных выражений. Процесс визуализации включает несколько этапов.

\subsubsection{Представление в виде дерева}

После разбора текста грамматики создаётся синтаксическое дерево (класс \texttt{RETree}), узлы которого представлены ниже.

\begin{itemize}
    \item \texttt{RETerminal} --- терминальный символ
    \item \texttt{RENonTerminal} --- нетерминальный символ
    \item \texttt{REMacro} --- макроопределение
    \item \texttt{REAnd} --- операция последовательности (\texttt{,})
    \item \texttt{REOr} --- операция альтернативы (\texttt{;})
    \item \texttt{REIteration} --- операция итерации (\texttt{*}, \texttt{+}, \texttt{\#})
    \item \texttt{REEmpty} --- пустой узел (epsilon)
\end{itemize}

\subsubsection{Преобразование в графические объекты}

Каждый узел дерева рекурсивно преобразуется в набор графических объектов (\texttt{DrawObject}).

\begin{itemize}
    \item \texttt{DrawObjectTerminal} --- овал с текстом терминала
    \item \texttt{DrawObjectNonTerminal} --- прямоугольник с именем нетерминала
    \item \texttt{DrawObjectMacro} --- пунктирный прямоугольник для макроса
    \item \texttt{DrawObjectPoint} --- точка разветвления для альтернатив
    \item \texttt{DrawObjectFirst} и \texttt{DrawObjectLast} --- треугольные маркеры начала и конца
    \item \texttt{Arrow} --- стрелки, соединяющие объекты
\end{itemize}

\subsubsection{Алгоритм размещения}

Алгоритм размещения является центральной частью системы визуализации. Он реализуется через рекурсивный обход дерева регулярного выражения с использованием семи основных методов размещения, представленных ниже.

\textbf{DrawObjectsToRight} --- размещение объектов по горизонтали справа от предыдущего элемента. Используется для последовательностей.

\textbf{DrawObjectsToDown} --- размещение объектов по вертикали вниз от точки разветвления. Используется для альтернатив.

\textbf{DrawObjectsCanDown} --- проверка возможности размещения вниз с расчётом требуемой высоты.

\textbf{DrawObjectsFromPoint} --- размещение от точки разветвления с созданием нижней ветви.

\textbf{DrawObjectsToPoint} --- размещение до точки схождения альтернатив.

\textbf{DrawObjectsToBothLastPoints} --- размещение с двумя выходными точками (для сложных конструкций).

\textbf{DrawObjectsToDownWithBothDownPoints} --- размещение вниз с двумя входными точками.

Каждый метод учитывает следующее.
\begin{itemize}
    \item Направление стрелок (вперёд/назад)
    \item Семантические действия
    \item Координаты размещения (x, y)
    \item Требуемую высоту и ширину
\end{itemize}

Алгоритм обеспечивает автоматическое вычисление координат всех элементов таким образом, чтобы диаграмма была компактной и читаемой, без пересечения линий.

\subsection{Эквивалентное портирование}

Эквивалентное портирование программной системы подразумевает перенос функциональности с одного языка программирования или платформы на другой с сохранением поведения системы, но с возможной модернизацией архитектуры и использованием современных технологий.

\subsubsection{Отличия от простого переписывания}

Эквивалентное портирование отличается от механического переписывания кода следующим.

\begin{itemize}
    \item \textbf{Анализа исходной системы}: понимание архитектурных решений, выявление ключевых алгоритмов и структур данных.
    \item \textbf{Адаптации к целевому языку}: использование идиом и возможностей современного C++, таких как умные указатели, move-семантика, RAII.
    \item \textbf{Рефакторинга}: улучшение структуры кода, выделение модульных компонентов, разделение ответственности.
    \item \textbf{Документирования}: создание документации API, комментариев в коде, руководств пользователя.
\end{itemize}

\subsubsection{Основные сложности портирования SynGT}

При портировании системы SynGT с Object Pascal на C++ возникают следующие вопросы.

\textbf{Управление памятью}: Pascal использует автоматический подсчёт ссылок для объектов, тогда как C++ требует явного управления временем жизни. Решение --- использование \texttt{std::unique\_ptr} и \texttt{std::shared\_ptr}.

\textbf{Коллекции}: замена специализированных структур данных Pascal (\texttt{TList}, \texttt{TStringList}) на стандартные контейнеры C++ (\texttt{std::vector}, \texttt{std::map}).

\textbf{Обработка строк}: различия в представлении строк (AnsiString в Pascal vs \texttt{std::string} в C++) и необходимость поддержки Unicode.

\textbf{Графический интерфейс}: оригинальная система использовала VCL (Visual Component Library) Delphi. При портировании требуется выбор современного кросс-платформенного фреймворка ImGui.

\textbf{Алгоритм размещения}: наиболее сложная часть портирования --- корректный перенос рекурсивного алгоритма размещения графических объектов с сохранением всех нюансов координации между методами.

\textbf{Система координат}: различия в системах координат графических библиотек требуют адаптации всех вычислений позиций элементов.

В итоге портированная система должна сохранить все ключевые алгоритмы исходной реализации, кроме этого предоставлять современную кодовую базу, пригодную для дальнейшего развития и интеграции в современные процессы разработки.